import crypto from 'crypto';

/**
 * Generates a unique token reference identifier.
 * Token references are used to track and identify tokenized cards
 * throughout the payment lifecycle without exposing actual card data.
 *
 * @returns A unique token reference string prefixed with "TOK_"
 */
export function generateTokenRef(): string {
  return `TOK_${crypto.randomBytes(16).toString('hex').toUpperCase()}`;
}

/**
 * Generates a Device Primary Account Number (DPAN) for a tokenized card.
 * DPANs replace the actual card number for payment transactions,
 * ensuring the real PAN is never transmitted during payments.
 * The prefix varies by card network to maintain EMV compliance.
 *
 * @param network - The card network (visa, mastercard, or amex)
 * @returns A 16-digit DPAN string that looks like a card number
 */
export function generateDPAN(network: string): string {
  // Token PANs start with specific ranges per network
  const prefixes: Record<string, string> = {
    visa: '4000',
    mastercard: '5000',
    amex: '3400',
  };
  const prefix = prefixes[network] || '4000';
  const random = crypto.randomBytes(6).toString('hex').substring(0, 12);
  return prefix + random;
}

/**
 * Generates a payment cryptogram for transaction authorization.
 * Cryptograms are one-time codes that prove the transaction was initiated
 * by a legitimate device with access to the token. In a real implementation,
 * this would be generated by the Secure Element using hardware-backed keys.
 *
 * @param tokenRef - The token reference for the card
 * @param amount - The transaction amount
 * @param merchantId - The merchant identifier
 * @param timestamp - Transaction timestamp in milliseconds
 * @returns A 16-character uppercase hex cryptogram
 */
export function generateCryptogram(
  tokenRef: string,
  amount: number,
  merchantId: string,
  timestamp: number
): string {
  const input = `${tokenRef}:${amount}:${merchantId}:${timestamp}`;
  const hash = crypto.createHash('sha256').update(input).digest('hex');
  return hash.substring(0, 16).toUpperCase();
}

/**
 * Validates a payment cryptogram against expected values.
 * Ensures the cryptogram was generated recently and matches
 * the expected transaction parameters. Uses timing-safe comparison
 * to prevent timing attacks.
 *
 * @param cryptogram - The cryptogram to validate
 * @param tokenRef - The token reference for the card
 * @param amount - The transaction amount
 * @param merchantId - The merchant identifier
 * @param timestamp - Transaction timestamp in milliseconds
 * @param toleranceMs - Maximum age of cryptogram in milliseconds (default: 5 minutes)
 * @returns True if the cryptogram is valid and recent, false otherwise
 */
export function validateCryptogram(
  cryptogram: string,
  tokenRef: string,
  amount: number,
  merchantId: string,
  timestamp: number,
  toleranceMs: number = 300000 // 5 minute tolerance
): boolean {
  // Check if timestamp is within tolerance
  const now = Date.now();
  if (Math.abs(now - timestamp) > toleranceMs) {
    return false;
  }

  const expected = generateCryptogram(tokenRef, amount, merchantId, timestamp);
  return crypto.timingSafeEqual(
    Buffer.from(cryptogram),
    Buffer.from(expected)
  );
}

/**
 * Generates a 6-character authorization code for approved transactions.
 * Authorization codes are provided by the card network to confirm
 * that a transaction was approved and can be used for reconciliation.
 *
 * @returns A 6-character uppercase hex authorization code
 */
export function generateAuthCode(): string {
  return crypto.randomBytes(3).toString('hex').toUpperCase();
}

/**
 * Identifies the card network based on the PAN prefix.
 * Uses standard BIN (Bank Identification Number) ranges:
 * - Amex: starts with 34 or 37
 * - Mastercard: starts with 5
 * - Visa: starts with 4 (default)
 *
 * @param pan - The Primary Account Number (card number)
 * @returns The identified card network
 */
export function identifyNetwork(pan: string): 'visa' | 'mastercard' | 'amex' {
  const firstDigit = pan[0];
  const firstTwo = pan.substring(0, 2);

  if (firstTwo === '34' || firstTwo === '37') {
    return 'amex';
  }
  if (firstDigit === '5') {
    return 'mastercard';
  }
  return 'visa';
}

/**
 * Validates a card number using the Luhn algorithm (Mod 10).
 * This checksum algorithm is used by all major card networks
 * to detect typos and transcription errors in card numbers.
 *
 * @param pan - The Primary Account Number to validate
 * @returns True if the card number passes Luhn validation
 */
export function validateLuhn(pan: string): boolean {
  const digits = pan.replace(/\D/g, '');
  let sum = 0;
  let isEven = false;

  for (let i = digits.length - 1; i >= 0; i--) {
    let digit = parseInt(digits[i], 10);

    if (isEven) {
      digit *= 2;
      if (digit > 9) {
        digit -= 9;
      }
    }

    sum += digit;
    isEven = !isEven;
  }

  return sum % 10 === 0;
}

/**
 * Masks a PAN for safe display, showing only the last 4 digits.
 * Used throughout the UI to represent cards without exposing
 * the full card number.
 *
 * @param pan - The Primary Account Number to mask
 * @returns A masked string like "**** **** **** 1234"
 */
export function maskPAN(pan: string): string {
  const last4 = pan.slice(-4);
  return `**** **** **** ${last4}`;
}

/**
 * Generates a secure random challenge for biometric authentication.
 * The challenge is sent to the device and must be signed by
 * the Secure Enclave to prove the biometric verification occurred.
 *
 * @returns A base64-encoded 32-byte random challenge
 */
export function generateChallenge(): string {
  return crypto.randomBytes(32).toString('base64');
}
